# Agent Collaboration v2: 검증 시나리오

> **Status**: Draft v2
> **Date**: 2026-02-26
> **Parent**: [AGENT-COLLABORATION-V2.md](./AGENT-COLLABORATION-V2.md)

---

## 1. 핵심 성공 조건

### 1.1 Handler/Observer 분리

| #   | 시나리오                                               | 기대 결과                                                                                                       | 검증 방법                                    |
| --- | ------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
| H1  | 채널에서 `@루다 이것 확인해줘`                         | 루다만 응답 (HANDLER). 다짐/이든/세움은 OBSERVER (기록만, 응답 없음)                                            | 채널에서 메시지 보내고 응답 봇 수 확인       |
| H2  | 채널에서 `프론트 진행 어때?` (멘션 없음)               | default agent만 응답. 나머지 OBSERVER                                                                           | 응답 봇이 default agent뿐인지 확인           |
| H3  | 채널에서 `@루다 @이든 이거 같이 봐줘`                  | 루다 = PRIMARY, 이든 = SECONDARY. **둘 다 HANDLER로 응답** (순서는 best-effort, 보장하지 않음). 나머지 OBSERVER | 두 봇 모두 응답하는지 확인 (순서는 비결정적) |
| H4  | OBSERVER 모드 봇의 다음 세션에서 이전 메시지 참조 가능 | 다짐에게 "아까 루다가 뭐라고 했어?" → **compact 기록 범위 내에서 요약 수준으로 참조 가능** (원문 재현은 불가)   | 다짐에게 직접 멘션으로 이전 대화 물어보기    |

### 1.2 스레드 참여자

| #   | 시나리오                                                       | 기대 결과                                                           | 검증 방법                                               |
| --- | -------------------------------------------------------------- | ------------------------------------------------------------------- | ------------------------------------------------------- |
| T1  | 루다가 `collaborate(eden, "코드 리뷰 해줘")` 호출              | 스레드 생성 + @이든 멘션. 참여자: {루다, 이든}                      | 스레드 생성 확인, 이든이 응답하는지 확인                |
| T2  | T1 스레드에서 이든이 멘션 없이 응답                            | 이든이 HANDLER로 처리 + 응답 ✅                                     | 이든이 스레드에서 응답하는지 확인                       |
| T3  | T1 스레드에서 루다가 멘션 없이 "한 가지 더 확인해줘"           | 이든이 HANDLER로 처리 (참여자이므로)                                | 이든이 추가 메시지에도 응답하는지 확인                  |
| T4  | T1 스레드에서 루다가 "@세움 도 확인해봐"                       | 세움이 참여자로 등록. 이후 멘션 없이도 HANDLER                      | 세움이 스레드에 참여하고 이후 멘션 없이 응답하는지 확인 |
| T5  | T1 스레드에서 다짐은 참여하지 않음                             | 다짐은 OBSERVER (스레드 메시지 무시)                                | 다짐이 스레드에서 아무런 응답을 하지 않는지 확인        |
| T6  | 게이트웨이 재시작 후 T1 스레드에서 이든이 멘션 없이 메시지     | 파일 캐시에서 참여자 복원 → 이든이 HANDLER                          | 재시작 후 스레드 참여자 인식 여부 확인                  |
| T7  | 파일 캐시 없이 재시작 후 T1 스레드에서 이든이 멘션 없이 메시지 | Safe Degradation: 멘션 없으면 HANDLER 안 됨. 이든이 멘션하면 재등록 | 재시작 + 캐시 삭제 후 동작 확인                         |

### 1.3 collaborate 도구

| #   | 시나리오                                                  | 기대 결과                      | 검증 방법                               |
| --- | --------------------------------------------------------- | ------------------------------ | --------------------------------------- |
| C1  | Discord 채널 세션에서 `collaborate(eden, "코드 리뷰")`    | 스레드 생성 + 전송 성공        | Discord에서 스레드 확인                 |
| C2  | webchat 세션에서 `collaborate(eden, "코드 리뷰")`         | 동일하게 성공 (기본 채널 사용) | webchat에서 명령 후 Discord 스레드 확인 |
| C3  | main 세션에서 `collaborate(eden, "코드 리뷰")`            | 동일하게 성공 (기본 채널 사용) | main 세션에서 협업 시작 가능한지 확인   |
| C4  | 존재하지 않는 에이전트: `collaborate(unknown_agent, ...)` | 즉시 실패 + 명확한 에러 메시지 | 에러 메시지에 매핑 설정 안내 포함 확인  |
| C5  | 오프라인 봇: `collaborate(eden, ...)` (이든 오프라인)     | 즉시 실패 + 에스컬레이션       | 에러 반환 + 운영 알림 확인              |

---

## 2. 루프 방지 시나리오

| #   | 시나리오                                                            | 기대 결과                                                    | 검증 방법                                            |
| --- | ------------------------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| L1  | discord-conversation-sink가 올린 메시지                             | 어떤 봇도 LLM 호출 안 함 (0회)                               | sink 메시지 후 모든 봇의 로그에서 LLM 호출 없음 확인 |
| L2  | Sink 스레드의 메시지가 Handler로 재진입                             | 재진입 없음 (드랍)                                           | sink 스레드 메시지 처리 로그 확인                    |
| L3  | 에이전트 A가 B에게 collaborate → B가 응답 → A가 다시 collaborate(B) | 스레드 내에서는 일반 대화로 처리 (collaborate 재호출 불필요) | collaborate 호출 횟수 확인                           |
| L4  | 같은 (A, B) 쌍이 5분 내 4회 collaborate 호출                        | 4회째에서 차단 + 경고                                        | collaborate 실패 + 경고 메시지 확인                  |
| L5  | 스레드에서 6msg/60s 초과                                            | Loop Guard 발동, 스레드 일시 중단                            | 빠른 메시지 연속 전송 후 차단 확인                   |

---

## 3. 스레드 재사용 시나리오

| #   | 시나리오                                      | 기대 결과                                                 | 검증 방법                    |
| --- | --------------------------------------------- | --------------------------------------------------------- | ---------------------------- |
| R1  | 같은 (루다→이든)으로 6시간 내 2회 collaborate | 두 번째 호출은 기존 스레드에 이어쓰기 (새 스레드 안 만듦) | 스레드 수 변화 없음 확인     |
| R2  | 같은 (루다→이든)으로 6시간 이후 collaborate   | 새 스레드 생성                                            | 새 스레드 생성 확인          |
| R3  | threadId를 명시적으로 지정해서 collaborate    | 항상 해당 스레드에 이어쓰기 (TTL 무관)                    | 지정된 스레드에 메시지 확인  |
| R4  | 게이트웨이 재시작 후 같은 쌍으로 collaborate  | ThreadRouteCache 파일에서 복원 → 기존 스레드 재사용       | 재시작 후 스레드 재사용 확인 |

---

## 4. 에러 분류 시나리오

| #   | 시나리오                       | 기대 결과                            | 검증 방법                           |
| --- | ------------------------------ | ------------------------------------ | ----------------------------------- |
| E1  | Discord API 403 (권한 없음)    | 즉시 실패, 재시도 없음, 에스컬레이션 | a2a-retry가 재시도하지 않는지 확인  |
| E2  | Discord API 404 (채널/봇 없음) | 즉시 실패, 재시도 없음, 에스컬레이션 | a2a-retry가 재시도하지 않는지 확인  |
| E3  | Discord API 429 (Rate Limit)   | Retry-After 헤더 대기 후 재시도      | 재시도 후 성공하는지 확인           |
| E4  | Discord API 5xx                | 지수 backoff로 3회 재시도            | 재시도 패턴 확인 (1s, 2s, 4s)       |
| E5  | Timeout (10초)                 | 3회 재시도 후 실패                   | 총 대기 시간 및 최종 실패 확인      |
| E6  | agentId 매핑 실패              | 즉시 실패 + 설정 안내 메시지         | 에러 메시지에 설정 가이드 포함 확인 |

---

## 5. Observer 비용 시나리오

| #   | 시나리오                              | 기대 결과                                            | 검증 방법                                    |
| --- | ------------------------------------- | ---------------------------------------------------- | -------------------------------------------- |
| O1  | 10개 봇이 같은 채널을 Observer로 관찰 | 각 봇당 최대 50개 compact 기록만 유지                | 1시간 후 각 봇의 Observer 기록 수 확인 (≤50) |
| O2  | 24시간 경과 후 Observer 기록          | TTL에 의해 자동 삭제                                 | 24시간 후 기록 수 확인                       |
| O3  | Observer 기록이 compact 포맷인지 확인 | sender + 첫 50자 + messageId + ts만 저장 (원문 아님) | 저장된 기록 형식 확인                        |
| O4  | Handler 메시지는 원문 보존            | compact 포맷이 아닌 원문 저장                        | Handler 세션 히스토리에서 원문 확인          |

---

## 6. 매핑 시나리오

| #   | 시나리오                                    | 기대 결과                                            | 검증 방법        |
| --- | ------------------------------------------- | ---------------------------------------------------- | ---------------- |
| M1  | `collaborate("eden", ...)`                  | agentId "eden" → botUserId 성공 조회                 | 정상 전송 확인   |
| M2  | `collaborate("default", ...)` (accountId)   | accountId "default" → botUserId 성공 조회 (fallback) | 정상 전송 확인   |
| M3  | 게이트웨이 시작 로그에 매핑 테이블 출력     | 모든 에이전트 ID → botUserId 매핑 확인 가능          | 시작 로그 확인   |
| M4  | 새 에이전트 추가 후 재시작 없이 collaborate | 실패 (동적 등록 미지원) → 재시작 필요 안내           | 에러 메시지 확인 |

---

## 7. 정책 통합 시나리오

| #   | 시나리오                              | 기대 결과                                             | 검증 방법                                                  |
| --- | ------------------------------------- | ----------------------------------------------------- | ---------------------------------------------------------- |
| P1  | Phase 4 완료 후 COLLABORATION.md 내용 | "Discord-first + collaborate 주류" 반영               | 문서 내용 확인                                             |
| P2  | Phase 4 완료 후 AGENTS.md 내용        | collaborate 가이드 + 스레드 규칙 포함. agentSend 제거 | 문서 내용 확인                                             |
| P3  | Phase 4 완료 후 A2A 컨텍스트          | "외부 채널 협업 금지" 제거, collaborate 허용          | sessions-send-helpers.ts 확인                              |
| P4  | sessions_send와 collaborate 병행 사용 | 각각의 용도에 맞게 사용 가능                          | 백그라운드 작업은 sessions_send, 가시적 협업은 collaborate |

---

## 8. 허용 채널 시나리오

| #   | 시나리오                               | 기대 결과                             | 검증 방법                 |
| --- | -------------------------------------- | ------------------------------------- | ------------------------- |
| S1  | allowlist에 있는 채널에서 collaborate  | 스레드 생성 성공                      | 정상 동작 확인            |
| S2  | allowlist에 없는 채널 ID로 collaborate | 즉시 실패 + "허용되지 않은 채널" 에러 | 에러 메시지 확인          |
| S3  | channelId 미지정 + 기본 채널 설정 있음 | 기본 채널에 스레드 생성               | 기본 채널에서 스레드 확인 |
| S4  | channelId 미지정 + 기본 채널 미설정    | collaborate 실패 + 설정 안내          | 에러 메시지 확인          |

---

## 9. 비동기 처리 시나리오 (Phase 1-2)

| #   | 시나리오                                               | 기대 결과                                          | 검증 방법                           |
| --- | ------------------------------------------------------ | -------------------------------------------------- | ----------------------------------- |
| A1  | 에이전트 A가 collaborate(B) 호출 후 사용자 메시지 수신 | A가 사용자 메시지를 정상 처리 (블로킹 없음)        | A의 응답 시간 정상 확인             |
| A2  | collaborate(B) 호출 후 즉시 반환                       | "이든에게 전달했습니다" 메시지 반환                | 즉시 반환 확인 (blocking 없음)      |
| A3  | B의 스레드 응답이 늦게 옴 (5분 후)                     | A는 이미 다른 작업 진행 중. B 응답은 스레드에 기록 | A의 세션이 블로킹되지 않았는지 확인 |

---

## 10. E2E 통합 시나리오

### 시나리오 A: 기본 협업 플로우

```
1. 사용자: "@루다 이든한테 인증 모듈 리뷰 부탁해줘"
2. 루다: HANDLER → "이든에게 전달하겠습니다" + collaborate(eden, "인증 모듈 코드 리뷰 부탁해")
3. Discord: 스레드 "[협업] 루다 → 이든 · 인증 모듈 코드 리뷰" 생성 + "@이든 인증 모듈 코드 리뷰 부탁해"
4. 이든: HANDLER (스레드 참여자) → 코드 리뷰 수행 → 스레드에 응답
5. 루다: ResponseTracker → "이든이 응답했습니다" (Phase 3)
6. 다짐: OBSERVER → 위 대화 전체가 히스토리에 기록됨
```

**검증 포인트**:

- [ ] 루다만 사용자 메시지에 응답
- [ ] 스레드 생성 + 이든 멘션
- [ ] 이든이 풀 컨텍스트로 응답 (MEMORY, SOUL 포함)
- [ ] 다짐이 아무 응답도 하지 않음
- [ ] 다짐에게 나중에 "아까 루다가 뭐라고 했어?" → 기록에서 참조 가능

### 시나리오 B: 다중 에이전트 협업

```
1. 사용자: "@루다 @이든 이 PR 같이 봐줘"
2. 루다: PRIMARY HANDLER → PR 분석 시작 → 응답
3. 이든: SECONDARY HANDLER → 루다 응답 참고 후 보충 의견
4. 세움/다짐: OBSERVER
```

### 시나리오 C: 스레드에서 에이전트 추가

```
1. 기존 스레드: 참여자 {루다, 이든}
2. 루다: "@세움 배포 관련 확인해줘"
3. 세움: 참여자로 등록 → HANDLER
4. 이후: 세움이 멘션 없이 스레드에서 대화 가능
```

### 시나리오 D: webchat에서 협업 시작

```
1. 사용자 (webchat): "이든한테 코드 리뷰 부탁해줘"
2. 루다 (webchat 세션): collaborate(eden, "코드 리뷰 부탁") → 기본 채널에 스레드 생성
3. 이든: Discord 스레드에서 응답
4. 사용자: Discord 스레드에서 대화 확인 가능
```

### 시나리오 E: 장애 복구

```
1. 게이트웨이 재시작 발생
2. ThreadParticipantMap 파일 캐시에서 복원
3. 기존 스레드에서 멘션 없이 대화 재개 가능
4. (파일 캐시 없는 경우) Safe Degradation → 멘션 기반만 동작
```

---

## 11. 성능 기준

| 항목                      | 기준                     | 비고                      |
| ------------------------- | ------------------------ | ------------------------- |
| collaborate() 응답 시간   | < 3초 (Discord API 포함) | 스레드 생성 + 메시지 전송 |
| Observer 기록 시간        | < 100ms                  | compact 포맷 저장         |
| Handler 결정 시간         | < 10ms                   | 멘션 파싱 + 참여자 조회   |
| ThreadParticipantMap 로드 | < 500ms                  | 파일 캐시에서 복원        |
| 스레드 재사용 캐시 조회   | < 5ms                    | in-memory Map             |
